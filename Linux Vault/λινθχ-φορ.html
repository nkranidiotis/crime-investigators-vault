<!DOCTYPE html> <html> <head> <meta charset="UTF-8"> <title>Linux Forensics Cheat Sheet</title> <style> body { background: #111; color: #eee; font-family: sans-serif; line-height: 1.4;} h1 { color: #FFD700; text-align: center; text-shadow: 0 0 5px #FFD700;} h2 { color: #FFA500; border-bottom: 1px solid #FFA500; margin-top: 1em;} .section { padding: 10px; margin-bottom: 20px; border: 1px solid #444; border-radius: 5px;} code { color: #FFEF00; background: none; } code.path { color: #FFA500; } ul { margin: 0; padding-left: 1.2em;} li { margin: 5px 0;}

	.logo {
	  display: block;
	  margin: 0 auto 20px auto; /* centers and adds bottom margin */
	  width: 150px; /* adjust size */
	  height: auto; /* keep proportions */
	}
	.footer {
      margin-top: 5px;
      text-align: center;
      color: #888;
      font-size: 14px;
    }
	.subtitle {
		font-size: 1.2rem;
		color: var(--neon);
		text-align: center;
		margin-top: -10px;
	}
	.subtitle a {
		color: var(--neon);
		text-decoration: none;
	}
	.subtitle a:hover {
		text-decoration: underline;
	}
	</style> </head> <body> 
<img src="logo-linux.png" alt="Linux Cyber Penguin" class="logo">

<h1>Linux Forensics Cheat Sheet (Debian/Ubuntu/Kali)</h1> <h2 class="subtitle">Nikolaos Kranidiotis • <a href="https://osec.gr" target="_blank">osec.gr</a></h2> <div class="section"> <h2>Quick Triage</h2> <ul> <li><code>w</code> – Show who’s logged in (current users) and their sessions.</li> <li><code>last -n 10</code> – List last 10 logins (from <code class="path">/var/log/wtmp</code>) and <code>lastb</code> for failed attempts.</li> <li><code>ps -aux --forest</code> – List processes with tree view to spot odd parent-child relations. Look for unusual processes or ones running as root with high PIDs.</li> <li><code>ss -tunap</code> (or <code>netstat -tunap</code>) – Show all listening ports and active network connections with associated processes.</li> <li><code>find / -mtime -1 -type f 2>/dev/null</code> – Find files modified in the last 24 hours (adjust timeframe) to spot recent changes.</li> <li><code>find / -perm -4000 2>/dev/null</code> – Identify SUID binaries (potential privilege escalation tools or planted backdoors).</li> <li><code>ls -alR /proc/*/exe 2>/dev/null | grep deleted</code> – Check for running processes with deleted executables (indicative of malware in memory).</li> <li>Quickly check for log tampering: e.g. <code>ls -l /var/log/*</code> for zero-length files (logs wiped by attacker).</li> </ul> </div> <div class="section"> <h2>Suspicious Artifacts Locations</h2> <ul> <li><strong>Temporary files:</strong> Check ephemeral dirs like <code class="path">/tmp</code>, <code class="path">/var/tmp</code>, <code class="path">/dev/shm</code> for dropped payloads or scripts.</li> <li><strong>Spool & Run:</strong> Inspect <code class="path">/var/spool</code> (e.g. mail, cron) and <code class="path">/var/run</code> for unexpected files or folders.</li> <li><strong>User directories:</strong> Look in user home directories for hidden files (prefix <code>.</code>) or unusual binaries; e.g. <code class="path">~/.ssh/</code>, <code class="path">~/.cache/</code>, <code class="path">~/.config/</code>.</li> <li><strong>System binaries:</strong> Verify integrity of critical system files in <code class="path">/bin</code>, <code class="path">/usr/bin</code>, <code class="path">/sbin</code> (attackers may replace common binaries). Use <code>dpkg -V</code> or <code>debsums -c</code> on Debian to find altered files.</li> <li><strong>Libraries & Modules:</strong> Scan <code class="path">/lib</code>, <code class="path">/usr/lib</code> for rogue .so files or kernel modules. Attackers might drop rootkits in <code class="path">/lib/modules/$(uname -r)</code> or via <code class="path">/etc/ld.so.preload</code>.</li> <li><strong>Web directories:</strong> If a web server is present, check <code class="path">/var/www</code> (or web app directories) for webshells or unfamiliar files.</li> </ul> </div> <div class="section"> <h2>Persistence & Autostart</h2> <ul> <li><strong>Systemd Services:</strong> List autostart services with <code>systemctl list-unit-files --state=enabled</code> and inspect <code class="path">/etc/systemd/system/</code> (and subdirs like <code class="path">multi-user.target.wants/</code>) for unauthorized .service files. Examine service definitions using <code>systemctl cat name.service</code> for suspicious commands.</li> <li><strong>Cron Jobs:</strong> Check system cron schedules in <code class="path">/etc/crontab</code>, <code class="path">/etc/cron.d/</code>, and user crontabs in <code class="path">/var/spool/cron/crontabs/</code>. Run <code>crontab -l -u &lt;user&gt;</code> for each user. Look for @reboot entries or strange schedules. Also review <code class="path">/etc/anacrontab</code> and <code class="path">/var/spool/anacron</code> for persistent tasks. Use <code>atq</code> to list pending at jobs.</li> <li><strong>Init Scripts:</strong> Investigate legacy init locations: <code class="path">/etc/init.d/</code> and scripts linked in <code class="path">/etc/rc*.d/</code> (SysV init). Also check <code class="path">/etc/rc.local</code> (executed at end of boot).</li> <li><strong>Shell Profiles:</strong> Attackers may persist via login scripts. Inspect <code class="path">/etc/profile</code>, <code class="path">/etc/bash.bashrc</code>, and scripts in <code class="path">/etc/profile.d/</code> (system-wide). For each user, review <code class="path">~/.bashrc</code>, <code class="path">~/.bash_profile</code>, <code class="path">~/.profile</code>, and even desktop autostart files (e.g. <code class="path">~/.config/autostart/*.desktop</code>) for injected commands.</li> <li><strong>Kernel Modules:</strong> Review <code class="path">/etc/modules</code> (modules to load at boot) and <code class="path">/etc/modprobe.d/</code> configs for suspicious entries. Use <code>lsmod</code> to see loaded modules and compare against known baseline. Attackers may load rootkit modules or alter module configs.</li> <li><strong>Other Mechanisms:</strong> Check <code class="path">/etc/inetd.conf</code> or <code class="path">/etc/xinetd.d/</code> for unauthorized network services. Also look at environment triggers like <code class="path">~/.ssh/authorized_keys</code> with embedded command= options (backdoor access) and <code class="path">~/.ssh/rc</code> scripts.</li> <li><strong>Scheduled Tasks (systemd timers):</strong> Run <code>systemctl list-timers --all</code> to list scheduled systemd timers (similar to cron) which might execute persistent malware on schedule.</li> </ul> </div> <div class="section"> <h2>Logs & Event History</h2> <ul> <li><strong>Authentication Logs:</strong> <code class="path">/var/log/auth.log</code> (Debian/Ubuntu) or <code class="path">/var/log/secure</code> (RHEL) – record SSH logins, sudo use, and auth failures. Search for keywords like "Accepted password", "Failed password", "sudo" etc. Also check <code class="path">/var/log/faillog</code> for failed login stats.</li> <li><strong>System Logs:</strong> <code class="path">/var/log/syslog</code> (Debian) or <code class="path">/var/log/messages</code> – general system messages, daemon outputs, and kernel events. Review for unusual errors or service restarts around incident time.</li> <li><strong>Kernel & Device Logs:</strong> <code class="path">/var/log/kern.log</code> – kernel-specific logs (watch for module load messages or Oops). <code class="path">/var/log/dmesg</code> – boot and driver messages (USB device insertions will appear here or in syslog). Use <code>dmesg | grep -i usb</code> to find USB events (external device connections).</li> <li><strong>Login Records:</strong> <code class="path">/var/log/wtmp</code> (all logins) and <code class="path">/var/log/btmp</code> (failed logins) store user login history. Use <code>last</code> and <code>lastb</code> to read these. <code class="path">/var/log/lastlog</code> shows last login per user (use <code>lastlog</code> command).</li> <li><strong>Application Logs:</strong> Look into service-specific logs under <code class="path">/var/log/</code> (e.g. <code class="path">apache2/access.log</code>, <code class="path">apache2/error.log</code>, <code class="path">mysql/error.log</code>, etc.) for signs of exploitation or exfiltration. Also check <code class="path">/var/log/cron</code> for cron job executions and <code class="path">/var/log/daemon.log</code> for other daemon events.</li> <li><strong>Audit Logs:</strong> If Auditd is running, inspect <code class="path">/var/log/audit/audit.log</code> for detailed security events (e.g. file access, process execution). Use <code>ausearch</code> and <code>aureport</code> to query these logs.</li> <li><strong>Log Integrity:</strong> Look for gaps or anomalies in timestamps that could indicate log tampering. Logs wiped by attackers (e.g. suddenly no entries for a period) or log files with suspiciously new creation dates are red flags.</li> </ul> </div> <div class="section"> <h2>File Carving & Deleted Files</h2> <ul> <li><strong>Foremost:</strong> Carve files from disk images by file type signatures. Example: <code>foremost -t jpg,pdf -i disk.img -o ./recovery</code> (carves JPG and PDF files from <code class="path">disk.img</code> into <code class="path">./recovery</code>). Omit <code>-t</code> to use all default file types or edit <code class="path">foremost.conf</code> to specify types.</li> <li><strong>Scalpel:</strong> A faster Foremost variant requiring configuration of file types in <code class="path">/etc/scalpel/scalpel.conf</code>. After uncommenting desired file types, run <code>scalpel /dev/sda1 -o /path/to/recovery_dir</code> to carve deleted files from a device or image.</li> <li><strong>extundelete:</strong> Undelete files on ext3/ext4 filesystems using journal data. Usage: <code>extundelete --restore-all /dev/sdX1</code> (or <code>--restore-file=path</code> for specific files) to recover to <code class="path">RECOVERED_FILES</code> directory. Ensure the volume is unmounted (or mounted read-only) before running.</li> <li><strong>The Sleuth Kit (TSK):</strong> Use TSK for low-level analysis: <ul> <li><code>fls -r -a -m / image.dd &gt; bodyfile.txt</code> – List all files (including deleted) from image and save in timeline bodyfile.</li> <li><code>ils -m image.dd</code> – List metadata of deleted files (in bodyfile format).</li> <li><code>icat image.dd &lt;inode&gt;</code> – Extract file content by inode number (even if deleted, if not overwritten).</li> </ul> </li> <li><strong>Photorec:</strong> (Part of TestDisk) Scans block device or image for known file signatures (similar to Foremost). Useful for carving common file types via an interactive console UI.</li> <li>Always work on disk <em>images</em> or read-only mounts. For live systems, consider <code>dd</code> imaging the volume or using <code>ddrescue</code> for damaged disks, then perform carving on the image to avoid altering the source.</li> </ul> </div> <div class="section"> <h2>Memory Acquisition & Analysis</h2> <ul> <li><strong>LiME (Linux Memory Extractor):</strong> Loadable kernel module for memory dumps. Compile the module on a system with identical kernel. Usage: <code>insmod lime-<span style="font-style:italic;">$(uname -r)</span>.ko "path=/dump/path.mem format=lime"</code> to write a full RAM dump (use <code>format=raw</code> for raw format). LiME also supports output over TCP (e.g., <code>"path=tcp:[COLLECTOR_IP]:4444"</code> to send dump to a remote listener).</li> <li><strong>AVML:</strong> Microsoft’s memory acquisition tool (precompiled) – simply run <code>./avml <span class="path">memory.lime</span></code> to dump memory to a file. Produces LiME format output without needing a kernel module (works on Azure VMs and Linux systems).</li> <li><strong>Volatility Framework:</strong> Use Volatility 3 (or Volatility 2 with profile) to analyze Linux memory dumps. Common plugins include: <ul> <li><code>linux.pslist</code> – List processes in memory.</li> <li><code>linux.pstree</code> – Process tree, showing parent/child relationships.</li> <li><code>linux.lsmod</code> – List loaded kernel modules (detect unknown modules/rootkits).</li> <li><code>linux.ifconfig</code>/<code>linux.netstat</code> (Volatility 2) or <code>linux.sockstat</code> – Show network interfaces and connections in memory.</li> <li><code>linux.bash</code> – Recover bash command history from memory (even if wiped on disk).</li> <li><code>linux.malfind</code> – Detect hidden or injected code segments in process memory.</li> </ul> Example: <code>vol.py -f memory.lime linux.pslist</code> (Volatility 3 uses <code>vol</code> or <code>vol3</code> command). Ensure you have the correct symbol table (Volatility 3 can use <code>banners.Banners</code> to identify kernel version and require a generated JSON profile).</li> <li><strong>Rekall:</strong> An alternative memory analysis framework (fork of Volatility) with built-in Linux profiles. Usage is similar, e.g., <code>rekall -f memory.lime pslist</code>.</li> <li><strong>Memory analysis tips:</strong> Look for suspicious processes not seen on disk, network connections in memory, signs of credential material (e.g. passwords in process memory), and kernel hooks. Consider dumping suspicious process memory (Volatility’s <code>linux.proc.*</code> plugins or using <code>dd</code> on <code class="path">/proc/[pid]/mem</code> with proper permissions) for further malware analysis.</li> </ul> </div> <div class="section"> <h2>Timeline Reconstruction</h2> <ul> <li><strong>The Sleuth Kit &amp; mactime:</strong> Generate filesystem timeline from an image: <ul> <li>Use <code>fls -r -m / image.dd &gt; bodyfile.txt</code> to create a body file of all FS entries (with MAC times).</li> <li>Then <code>mactime -b bodyfile.txt -d -z UTC &gt; timeline.csv</code> to produce a CSV timeline. (Use appropriate timezone for the system.)</li> </ul> The timeline will include file creations, modifications, and access times to correlate system events.</li> <li><strong>log2timeline/Plaso:</strong> Use <code>log2timeline.py</code> to create a supertimeline from various log files and artifacts. Example: <code>log2timeline.py incident.plaso disk.img</code> will parse file system and known log formats into a Plaso storage file. Then use <code>psort.py -o CSV -w timeline.csv incident.plaso</code> to output a combined timeline. Plaso incorporates many artifact parsers (event logs, browser history, etc.) beyond just file timestamps.</li> <li><strong>Manual Log Timeline:</strong> Correlate system logs (auth, syslog, etc.) around key timestamps. For instance, if an intrusion was detected at a certain time, review all log entries 10–15 minutes before and after across auth.log, syslog, web logs, etc., to piece together a sequence of events.</li> <li><strong>Timeline Analysis:</strong> Look for clusters of events (multiple file modifications or log entries in short succession) that might indicate attacker activity. Use tools like Timesketch or ELK stack to visualize timelines for large datasets, or a spreadsheet to filter and sort CSV timelines.</li> <li><strong>MAC times caveat:</strong> Remember that file timestamps can be altered by attackers (anti-forensics) or reset by certain activities (e.g. copying files preserves timestamps by default). Always consider the timeline in context with other evidence (such as logs or memory captures).</li> </ul> </div> <div class="section"> <h2>Network & Exfiltration</h2> <ul> <li><strong>Live Connections:</strong> Use <code>ss -tulnp</code> or <code>netstat -tulnp</code> to list listening ports and established TCP/UDP connections with PID/Program names. Check for unexpected listeners (e.g., backdoor shells on high ports) or outbound connections to unfamiliar IPs. Also <code>lsof -i -P -n</code> can reveal processes with network sockets open.</li> <li><strong>Network Sniffing:</strong> Capture traffic with <code>tcpdump</code> (e.g., <code>tcpdump -nn -w capture.pcap -i eth0</code> to log all interface traffic) or <code>tshark</code> for more filtering. If exfiltration is suspected, filter by known attacker IP or uncommon ports/protocols (e.g., DNS or ICMP tunneling).</li> <li><strong>Protocol Analysis:</strong> Use <code>tshark -r capture.pcap -Y "http or dns or ftp"</code> to quickly find cleartext creds or data leaks in common protocols. Look at DNS queries for suspicious domains, HTTP for large data posts or strange user-agents, etc.</li> <li><strong>Zeek (Bro):</strong> Run Zeek on a pcap (<code>zeek -r capture.pcap</code>) to generate high-level logs of connections, HTTP sessions, DNS queries, files transferred, etc. Review these logs (conn.log, http.log, dns.log, files.log) for anomalies like large outbound transfers or connections to blacklisted domains.</li> <li><strong>System Logs for Exfil:</strong> Check shell history or commands for use of network utilities (<code>scp</code>, <code>ftp</code>, <code>wget</code>/<code>curl</code> to external sites, <code>netcat</code>) around the incident. Also inspect <code class="path">/var/log/auth.log</code> for port-forwarding or tunneling attempts via SSH (e.g., using <code>ssh -D</code> or <code>ssh -L</code> options).</li> <li><strong>Firewall Logs:</strong> If available (e.g., iptables logging or UFW logs in <code class="path">/var/log/ufw.log</code>), review for unusual outbound connections or data volume. Commands like <code>iptables -L -v -n</code> show packet counts per rule, which might indicate volumes of traffic if logging rules are in place.</li> <li><strong>Indicators of Exfil:</strong> Large spikes in network usage, presence of archive files (zip, 7z, tar) in temp directories, or use of transfer tools like <code>rsync</code>, <code>scp</code> by suspicious accounts. Also search for any encoded blobs in logs or on disk that might represent packaged data (e.g., a big Base64 blob in an outbound email or script).</li> </ul> </div> <div class="section"> <h2>Malware Hunting & IOCs</h2> <ul> <li><strong>Filesystem Search:</strong> Hunt for common malicious patterns. For instance: <ul> <li>Search for Base64 or other encoding usage: <code>grep -R "base64" /etc /home 2>/dev/null</code> (attackers often hide commands or data in base64).</li> <li>Search for suspicious keywords: <code>grep -R -E "nc -e|/bin/sh|bash -i|exec 5&lt;&gt;/dev/tcp" / 2>/dev/null</code> to find signs of reverse shells/backdoors.</li> <li>Find scripts with odd shebangs or paths (e.g., referencing <code class="path">/dev/shm</code> or <code class="path">/tmp</code>).</li> </ul> </li> <li><strong>Hash & Scan:</strong> Generate hashes (MD5/SHA1/SHA256) of unidentified binaries and compare against malware databases. Use <code>sha256sum *</code> to list hashes, then cross-check any unknown ones via VirusTotal or threat intelligence sources.</li> <li><strong>Binary Clues:</strong> Use <code>strings</code> on suspicious binaries for hints (IP addresses, URLs, suspicious function names). Check for packer markers (e.g., "UPX" in output). Use <code>file</code> to identify file type (ELF, script, etc.) and <code>ldd</code> on ELF to see linked libraries (malware may link unusual libraries).</li> <li><strong>Rootkit Checks:</strong> Look for rootkit behaviors: <ul> <li>Hidden modules: cross-verify <code>lsmod</code> vs <code>cat /proc/modules</code> for discrepancies. Run tools like <code>chkrootkit</code> and <code>rkhunter</code> (with updated DB) to detect known rootkits.</li> <li>LD Preload: Check <code class="path">/etc/ld.so.preload</code> for any entries (normally empty/nonexistent; any .so listed is suspicious).</li> <li>Hidden processes: Compare <code>ps</code> output with <code>proc</code> filesystem entries or use <code>pstree</code> to spot processes with no parent or odd names. Also ensure no unexpected process is listening on network ports (per above network checks).</li> </ul> </li> <li><strong>Autorun IOCs:</strong> Re-check persistence locations for malware clues: <ul> <li>New or modified service unit files in <code class="path">/etc/systemd/system/</code> (especially with unusual names).</li> <li>Unexpected executables in <code class="path">/etc/cron.*</code> or <code class="path">/etc/init.d/</code>.</li> <li>Suspicious additions in shell profiles (e.g., an alias or function that launches malware, or a LD_PRELOAD export).</li> </ul> </li> <li><strong>User Activity:</strong> Review shell history files (e.g. <code class="path">~/.bash_history</code>) for strange commands (downloading files, altering permissions, compiling code). Even if attackers cleared history, partial traces might remain or be found in memory (Volatility’s linux.bash plugin). Also check <code class="path">~/.ssh/authorized_keys</code> for unfamiliar keys (a planted key = persistence).</li> <li><strong>Indicators in Logs:</strong> Look for multiple failed logins followed by a success (brute-force) in auth logs, or a sudden use of <code>sudo</code> by a new user (privilege escalation). Check for references to known hack tools or exploit scripts in logs. Search logs for keywords like "Accepted publickey" (new SSH key usage), "UID=0" (unexpected root actions), or known malware process names.</li> <li><strong>YARA Scan:</strong> Consider running YARA rules on suspicious files or memory dumps to identify known malware. Use community rule sets (e.g., from AlienVault OTX or GitHub repos) for Linux threats. Scan critical dirs and compare hits against threat intel databases.</li> </ul> </div> <div class="section"> <h2>Credential &amp; Sensitive Data</h2> <ul> <li><strong>Password Hashes:</strong> <code class="path">/etc/shadow</code> contains hashed passwords for user accounts (root-only access). Check for new accounts or weak hashes (passwordless entries are marked <code>!</code> or <code>*</code>). <code class="path">/etc/passwd</code> lists all users; ensure no unauthorized accounts, especially none with UID 0 (root) besides root itself.</li> <li><strong>SSH Keys:</strong> Inspect <code class="path">~/.ssh/authorized_keys</code> for unauthorized public keys (attackers often add their own key for persistence). Also collect any private keys (e.g., <code class="path">~/.ssh/id_rsa</code>) on the system – they might be stolen. Check <code class="path">~/.ssh/known_hosts</code> for hosts the attacker connected to or from.</li> <li><strong>Stored Credentials:</strong> Browser-stored passwords (if a desktop system): For Firefox, check <code class="path">~/.mozilla/firefox/</code> (look for <code>logins.json</code> and <code>key4.db</code> files); for Chrome/Chromium, <code class="path">~/.config/google-chrome/Default/Login Data</code> (SQLite DB). Also consider saved VPN passwords, email client creds, or Wi-Fi passwords (NetworkManager configs).</li> <li><strong>Keyrings & Vaults:</strong> Linux desktops use keyrings (e.g., GNOME Keyring files in <code class="path">~/.local/share/keyrings/</code> or <code class="path">~/.gnome2/keyrings/</code>) and KDE Wallet. These may contain saved credentials (SSH passphrases, web passwords). If obtainable (unlocked or cracked), they can reveal lots of stored secrets.</li> <li><strong>Cloud/API Keys:</strong> Look for cloud config files containing keys or tokens: e.g., <code class="path">~/.aws/credentials</code> (AWS keys), <code class="path">~/.azure/azureProfile.json</code>, <code class="path">~/.gcp/</code>, or config files for CI/CD tools (Jenkins, Docker registries). These can be high-value for attackers.</li> <li><strong>Memory for Creds:</strong> In memory dumps, search for cleartext credentials: e.g., strings that look like passwords or AWS secrets. Also consider dumping process memory of authentication daemons (ssh, sudo) via volatility to see if any passwords or keys lingered. If kernel dumps (core dumps in <code class="path">/var/crash</code>) exist from crashes, they might contain secrets in process memory at crash time.</li> </ul> </div> <div class="section"> <h2>Hidden & Temp Files</h2> <ul> <li><strong>Dotfiles & Hidden Dirs:</strong> Use <code>find / -type f -name ".*"</code> and similarly for <code>-type d</code> to locate hidden files/directories. Attackers hide data or scripts with a dot prefix. Common examples: hidden cron scripts (e.g. <code class="path">/etc/cron.d/.something</code>), or directories named ".. " (dot-dot-space) to confuse listing. Inspect any such hidden artifact closely.</li> <li><strong>/tmp &amp; /dev/shm:</strong> World-writable temp locations are often used for malicious payloads or staging. Look for executable files in <code class="path">/tmp</code> and <code class="path">/dev/shm</code> (e.g., <code>find /tmp -type f -perm -111</code>). Also list any FIFOs (named pipes) via <code>find /tmp -type p</code> – malware may use these for communication. Remember these paths are not persisted after reboot, so live response is key.</li> <li><strong>/dev abuse:</strong> Review the <code class="path">/dev</code> directory for any regular files. All entries should be device nodes or symlinks. An attacker might hide data as a "device", e.g., create <code class="path">/dev/.sock</code> or <code class="path">/dev/ptmx\n</code> (with a newline) to conceal it. Use <code>find /dev -type f</code> to identify any non-device files.</li> <li><strong>Extended Attributes:</strong> Linux files can have extended attributes (xattr) which might store hidden data or flags. Use <code>lsattr -R /</code> to find files with attributes like <code>i</code> (immutable) which attackers use to prevent log deletion or tampering. Use <code>getfattr -R -d /</code> to dump all xattrs and search for suspicious content or unusually large xattrs.</li> <li><strong>Cleanup Traces:</strong> Attackers often remove their files. Look for clues of deleted files: log entries complaining about missing files, bash history showing use of `rm` commands, or directory gaps (forensic tools like extundelete or TSK fls can help enumerate deleted files). Also check <code class="path">/var/tmp</code> and <code class="path">/var/crash</code> for any leftovers or crash dumps.</li> <li><strong>Memory-only Files:</strong> Some malware runs purely in memory (fileless). However, they might leave handles open. Check <code>/proc/<em>pid</em>/exe</code> symlinks: if an executable shows "<code>(deleted)</code>", that process might be running a file that was deleted (common for fileless malware). Also examine <code>/proc/<em>pid</em>/fd</code> for any mapped files in deleted state or living in /dev/shm.</li> </ul> </div>
</body> </html>